<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <!-- 
        认识队列
        受限的线性结构
        已经学习了一种受限的线性结构：栈结构
        并且已经知道这种受限得数据结构对于解决某特定问题，会有特别的效果
        队列（Queue），他是一种受限的线性表，先进先出（FIFO First In First In First Out）
        受限之处在于他只允许在表的前端（front）进行删除操作
        而在表的后端（rear）进行插入操作

        队列的常见操作
        enqueue(element):向队列尾部添加一个(或多个)新的项
        dequeue():移出队列的第一(即排在队列最前面得)项
        front();返回队列中第一个元素----最先被添加,也将是先被移除得元素,队列不做任何变动
        (不移出元素,只返回元素信息---与Stack类的peek方法非常类似).
        isEmpty():如果队列中不包含任何元素返回true,否则返回false
        size():返回队列包含的元素个数,与数组得length属性类似.
        toString();将队列中的内容,转成字符串形式

     -->
</body>
<script>
    // 队列结构封装
    // 队列的实现和栈一样,有两种方案
    // 基于数组实现
    // 基于链表实现
    function Queue(){
        this.items = [];
        // 将元素添加到队列中
        Queue.prototype.onqueue = function(element){
            this.items.push(element)
        }
        // 删除最前面的队列
        Queue.prototype.dequeue = function(){
           return this.items.shift();
        }
        // 查看前端的元素
        Queue.prototype.front = function(){
            return this.items[0]
        }
        Queue.prototype.isEmpty = function(){
            this.items.isEmpty.length == 0
        }
        Queue.prototype.size = function(){
           return this.items.length
        }
        Queue.prototype.toString = function(){
            var arr = '';
            for(var i = 0 ; i<this.items.length;i++){
                arr += this.items[i]+' ';
            }
            return arr;
        }
    }
    var queue = new Queue();
    // queue.onqueue('aaa');
    // queue.onqueue('bbb');
    // queue.onqueue('ccc');
    // queue.onqueue('ddd');
    // alert(queue)

    
    function passGame(nameList,num){
     // 创建一个队列结构
     var queue = new Queue();

    //  2 将所有人加入到队列
    for(var i = 0 ; i <nameList.length;i++){
        queue.onqueue(nameList[i]);
    }
console.log(queue);
    while(queue.size()>1){
        // 3 开始数数字
    // 不是num得时候,重新加入到队列的末尾
    // 是num这个数字的时候,将其从队列中删除
     for(var i = 0 ; i <num-1;i++){
        queue.onqueue(queue.dequeue())
     }
    //  因为for循环固定得个数后将前面的元素添加到后
    // 面就停止了  所以现在删除的话就是你要删除的那个元素
     queue.dequeue();
    }
     alert(queue.size())
     var endName = queue.front();
     alert('最终剩下的人' + endName)
     return nameList.indexOf(endName)
    }
    names =['asdf','asddddd','fh','hj','yui']
  alert(passGame(names,3))
</script>
</html>